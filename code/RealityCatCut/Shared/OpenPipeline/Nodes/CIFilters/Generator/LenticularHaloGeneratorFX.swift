//
//  Copyright Â© 2022 James Boo. All rights reserved.
//


import SwiftUI

class LenticularHaloGeneratorFX: BaseGeneratorFX {
       
    @Published var centerX:Float = 150
    @Published var centerY:Float = 150
    @Published var colorx:Color = .white
    @Published var color:CIColor = .white
    @Published var colorStr:String = "white"
    @Published var haloRadius:Float = 70.0
    @Published var haloWidth:Float = 87.0
    @Published var haloOverlap:Float = 0.77
    @Published var striationStrength:Float = 0.5
    @Published var striationContrast:Float = 1.0
    @Published var time:Float = 0.0

    let description = "BETA NODE: Simulates a halo that is generated by the diffraction associated with the spread of a lens. This filter is typically applied to another image to simulate lens flares and similar effects. Width refers to the width of the halo, from its inner radius to its outer radius."

    override init()
    {
        let name="CILenticularHaloGenerator"
        super.init(name)
        desc=description
        /*
        print(CIFilter.localizedName(forFilterName: name))
        print(CIFilter.localizedDescription(forFilterName: name))
        print(CIFilter.localizedReferenceDocumentation(forFilterName: name))
            
        print("time")
        if let attribute = CIFilter.lenticularHaloGenerator().attributes["inputTime"] as? [String: AnyObject]
        {
           let minimum = attribute[kCIAttributeSliderMin] as? Float
           let maximum = attribute[kCIAttributeSliderMax] as? Float
           let defaultValue = attribute[kCIAttributeDefault] as? Float
            
            print(minimum)
            print(maximum)
            print(defaultValue)
            
        }
        
        print("striationContrast")
        if let attribute = CIFilter.lenticularHaloGenerator().attributes["inputStriationContrast"] as? [String: AnyObject]
        {
           let minimum = attribute[kCIAttributeSliderMin] as? Float
           let maximum = attribute[kCIAttributeSliderMax] as? Float
           let defaultValue = attribute[kCIAttributeDefault] as? Float
            
            print(minimum)
            print(maximum)
            print(defaultValue)
            
        }
        
        print("striationStrength")
        if let attribute = CIFilter.lenticularHaloGenerator().attributes["inputStriationStrength"] as? [String: AnyObject]
        {
           let minimum = attribute[kCIAttributeSliderMin] as? Float
           let maximum = attribute[kCIAttributeSliderMax] as? Float
           let defaultValue = attribute[kCIAttributeDefault] as? Float
            
            print(minimum)
            print(maximum)
            print(defaultValue)
            
        }
        
        print("haloOverlap")
        if let attribute = CIFilter.lenticularHaloGenerator().attributes["inputHaloOverlap"] as? [String: AnyObject]
        {
           let minimum = attribute[kCIAttributeSliderMin] as? Float
           let maximum = attribute[kCIAttributeSliderMax] as? Float
           let defaultValue = attribute[kCIAttributeDefault] as? Float
            
            print(minimum)
            print(maximum)
            print(defaultValue)
            
        }
        
        print("haloRadius")
        if let attribute = CIFilter.lenticularHaloGenerator().attributes["inputHaloRadius"] as? [String: AnyObject]
        {
           let minimum = attribute[kCIAttributeSliderMin] as? Float
           let maximum = attribute[kCIAttributeSliderMax] as? Float
           let defaultValue = attribute[kCIAttributeDefault] as? Float
            
            print(minimum)
            print(maximum)
            print(defaultValue)
            
        }
        
        print("haloWidth")
        if let attribute = CIFilter.lenticularHaloGenerator().attributes["inputHaloWidth"] as? [String: AnyObject]
        {
           let minimum = attribute[kCIAttributeSliderMin] as? Float
           let maximum = attribute[kCIAttributeSliderMax] as? Float
           let defaultValue = attribute[kCIAttributeDefault] as? Float
            
            print(minimum)
            print(maximum)
            print(defaultValue)
            
        }
        */

              
    }

    enum CodingKeys : String, CodingKey {
        case centerX
        case centerY
        case color
        case haloRadius
        case haloWidth
        case haloOverlap
        case striationStrength
        case striationContrast
        case time
    }

    required init(from decoder: Decoder) throws {
        try super.init(from: decoder)
        let values = try decoder.container(keyedBy: CodingKeys.self)
        desc=description
        
        centerX = try values.decodeIfPresent(Float.self, forKey: .centerX) ?? 0.0
        centerY = try values.decodeIfPresent(Float.self, forKey: .centerY) ?? 0.0
        //colorStr = try values.decodeIfPresent(String.self, forKey: .color) ?? "blue"
        //color = getColorFromString(colorStr: colorStr)
        let colorData = try values.decodeIfPresent(Data.self, forKey: .color) ?? nil
        if colorData != nil
        {
            let uicolor=try NSKeyedUnarchiver.unarchivedObject(ofClass: UIColor.self, from: colorData!)!
            color = CIColor(color:uicolor)
            colorx = Color(uicolor)
        }
        haloRadius = try values.decodeIfPresent(Float.self, forKey: .haloRadius) ?? 0.0
        haloWidth = try values.decodeIfPresent(Float.self, forKey: .haloWidth) ?? 0.0
        haloOverlap = try values.decodeIfPresent(Float.self, forKey: .haloOverlap) ?? 0.0
        striationStrength = try values.decodeIfPresent(Float.self, forKey: .striationStrength) ?? 0.0
        striationContrast = try values.decodeIfPresent(Float.self, forKey: .striationContrast) ?? 0.0
        time = try values.decodeIfPresent(Float.self, forKey: .time) ?? 0.0

    }
    
    override func encode(to encoder: Encoder) throws {
        try super.encode(to: encoder)
  
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(centerX, forKey: .centerX)
        try container.encode(centerY, forKey: .centerY)
        //try container.encode(colorStr, forKey: .color)
        //try container.encode(colorStr, forKey: .color)
        try container.encode(try NSKeyedArchiver.archivedData(withRootObject: UIColor(ciColor: color), requiringSecureCoding: false), forKey: .color)
        
        try container.encode(haloRadius, forKey: .haloRadius)
        try container.encode(haloWidth, forKey: .haloWidth)
        try container.encode(haloOverlap, forKey: .haloOverlap)
        try container.encode(striationStrength, forKey: .striationStrength)
        try container.encode(striationContrast, forKey: .striationContrast)
        try container.encode(time, forKey: .time)

    }
    
    override func setupProperties(_ parent: FiltersX?)
    {
        super.setupProperties(parent)
        
        if parent != nil{
            centerX=Float(size.width/2.0)
            centerY=Float(size.height/2.0)
        }
        
    }
    
    override func adjustPropertiesToBounds(_ parent: FiltersX?)
    {
        super.adjustPropertiesToBounds(parent)
        
        centerX = centerX > Float(size.width) ? Float(size.width) : centerX
        centerY = centerY > Float(size.height) ? Float(size.height) : centerY
        
    }
    
    //deprecate
    override func getCIFilter(currentImage: CIImage, beginImage: CIImage) -> CIFilter? {
        
        //revisit size may be smaller.
        var currentCIFilter: CIFilter
        if ciFilter != nil {
            print("current CILenticularHaloGenerator")
            currentCIFilter = ciFilter!
        } else {
            print("new CILenticularHaloGenerator")
            currentCIFilter = CIFilter(name: type)!
            ciFilter=currentCIFilter
        }
        
        let tcenter=CIVector(x:CGFloat(centerX),y:CGFloat(centerY))
        currentCIFilter.setValue(tcenter, forKey: kCIInputCenterKey)
        currentCIFilter.setValue(color, forKey: kCIInputColorKey)
        currentCIFilter.setValue(haloRadius, forKey: "inputHaloRadius")
        currentCIFilter.setValue(haloWidth, forKey: "inputHaloWidth")
        currentCIFilter.setValue(haloOverlap, forKey: "inputHaloOverlap")
        currentCIFilter.setValue(striationStrength, forKey: "inputStriationStrength")
        currentCIFilter.setValue(striationContrast, forKey: "inputStriationContrast")
        currentCIFilter.setValue(time, forKey: kCIInputTimeKey)

        return currentCIFilter
    }

    //ANCHISES
    override func getCIFilter(_ ciImage: CIImage) -> CIFilter {
        
        var currentCIFilter: CIFilter
        
        if ciFilter != nil {
            currentCIFilter = ciFilter!
        } else {
            currentCIFilter = CIFilter(name: type)!
            ciFilter=currentCIFilter
  
        }
        
        let tcenter=CIVector(x:CGFloat(centerX),y:CGFloat(centerY))
        currentCIFilter.setValue(tcenter, forKey: kCIInputCenterKey)
        currentCIFilter.setValue(color, forKey: kCIInputColorKey)
        currentCIFilter.setValue(haloRadius, forKey: "inputHaloRadius")
        currentCIFilter.setValue(haloWidth, forKey: "inputHaloWidth")
        currentCIFilter.setValue(haloOverlap, forKey: "inputHaloOverlap")
        currentCIFilter.setValue(striationStrength, forKey: "inputStriationStrength")
        currentCIFilter.setValue(striationContrast, forKey: "inputStriationContrast")
        currentCIFilter.setValue(time, forKey: kCIInputTimeKey)

        return currentCIFilter
        
    }
}
